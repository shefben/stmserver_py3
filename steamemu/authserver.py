import threading, logging, struct, binascii, time, socket, ipaddress, os.path, ast, random, pprint, datetime

from Crypto.Hash import SHA

import steam
from . import config
import globalvars
def preprocess_input(input_str):
    # Add a closing brace at the end if the input ends with an open brace
    if input_str.rstrip().endswith("{"):
        input_str += "}"

    # Replace empty sub-dictionaries with a placeholder
    return input_str.replace(": {},", ": '__EMPTY_SUB_DICT__',")

class authserver(threading.Thread):
    def __init__(self, xxx_todo_changeme, config) :
        (socket, address) = xxx_todo_changeme
        threading.Thread.__init__(self)
        self.socket = socket
        self.address = address
        self.config = config

    def run(self):
        log = logging.getLogger("authsrv")

        clientid = str(self.address) + ": "

        log.info(clientid + "Connected to Auth Server")

        command = self.socket.recv(13)
        
        log.debug(":" + binascii.b2a_hex(command[1:5]) + ":")
        log.debug(":" + binascii.b2a_hex(command) + ":")

        if command[1:5] == b"\x00\x00\x00\x04" or command[1:5] == b"\x00\x00\x00\x01" or command[1:5] == b"\x00\x00\x00\x02" or command[1:5] == b"\x00\x00\x00\x03" :

            self.socket.send(b"\x00" + socket.inet_aton(self.address[0]))
            log.debug((str(socket.inet_aton(self.address[0]))))
            log.debug((str(socket.inet_ntoa(socket.inet_aton(self.address[0])))))

            command = self.socket.recv_withlen()

            if len(command) > 1 and len(command) < 256 :
            
                usernamelen = struct.unpack(">H", command[1:3])[0]
                
                userblob = {}

                username = command[3:3 + usernamelen]
                
                #print "user:" + username + ":"
                log.info(clientid + "Processing logon for user: " + username) # 7465737431
                log.debug(clientid + "Username length: " + str(usernamelen)) # 0005

                
                if (os.path.isfile("files/users/" + username + ".py")) :#and legacyuser == 0 :
                    with open("files/users/" + username + ".py", 'r') as f:
                        userblobstr = f.read()
                        preprocessed_blobstr = preprocess_input(userblobstr[16:len(userblobstr)])
                        userblob = ast.literal_eval(preprocessed_blobstr)
                    #print(userblob)
                    blocked = binascii.b2a_hex(userblob[b'\x0c\x00\x00\x00'])
                    if blocked == "0001" :
                        log.info(clientid + "Blocked user: " + username)
                        self.socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
                        command = self.socket.recv_withlen()
                        steamtime = steam.unixtime_to_steamtime(time.time())
                        tgt_command = b"\x04" #BLOCKED
                        padding = b"\x00" * 1222
                        ticket_full = tgt_command + steamtime + padding
                        self.socket.send(ticket_full)
                    else :
                        personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
                        #print(personalsalt)
                        self.socket.send(personalsalt) #NEW SALT PER USER
                        command = self.socket.recv_withlen()
                        key = userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16] #password hash generated by client on user creation, passwordCypherRijndaelKey/authenticationRijndaelKey in TINserver
                        #print(binascii.b2a_hex(key))
                        IV = command[0:16]
                        #print(binascii.b2a_hex(IV))
                        encrypted = command[20:36]
                        #print(binascii.b2a_hex(encrypted))
                        decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, IV, encrypted))
                        log.debug(clientid + "Authentication package: " + decodedmessage)
                
                        if not decodedmessage.endswith("04040404") :
                            wrongpass = "1"
                            log.info(clientid + "Incorrect password entered for: " + username)
                        else :
                            wrongpass = "0"                
                
                        # create login ticket
                        execdict = {}
                        execdict_new = {}
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                        secretkey = {b'\x05\x00\x00\x00'}
                        def without_keys(d, keys) :
                            return {x: d[x] for x in d if x not in keys}
                        execdict_new = without_keys(execdict, secretkey)
                        #print(execdict)
                        print(execdict_new)
                        blob = steam.blob_serialize(execdict_new)
                        print(blob)
                        bloblen = len(blob)
                        log.debug("Blob length: " + str(bloblen))
                        innerkey = binascii.a2b_hex("10231230211281239191238542314233") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                        blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                        blob_signature = steam.sign_message(innerkey, blob_encrypted)
                        blob_encrypted_len = 10 + len(blob_encrypted) + 20
                        blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
                        currtime = time.time()
                        outerIV = binascii.a2b_hex("92183129534234231231312123123353")
                        #steamid = binascii.a2b_hex("0000" + "80808000" + "00000000")
                        steamUniverse = "0000"
                        steamid = binascii.a2b_hex(steamUniverse + binascii.b2a_hex(userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16]))
                        #servers = binascii.a2b_hex("451ca0939a69451ca0949a69")
                        #authport = struct.pack("<L", int(port))
                        if self.config["public_ip"] != "0.0.0.0" :
                            bin_ip = steam.encodeIP((self.config["public_ip"], self.config["validation_port"]))
                        else :
                            bin_ip = steam.encodeIP((self.config["server_ip"], self.config["validation_port"]))
                        #bin_ip = steam.encodeIP(("172.21.0.20", "27039"))
                        servers = bin_ip + bin_ip
                        times = steam.unixtime_to_steamtime(currtime) + steam.unixtime_to_steamtime(currtime + (60*60*24*28))
                        subheader = innerkey + steamid + servers + times
                        subheader_encrypted = steam.aes_encrypt(key, outerIV, subheader)
                        subhead_decr_len = b"\x00\x36"
                        subhead_encr_len = b"\x00\x40"
                        if globalvars.tgt_version == "1" : #nullData1
                            subheader_encrypted = b"\x00\x01" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted #TTicket_SubHeader (EncrData)
                            log.debug(clientid + "TGT Version: 1") #v2 Steam
                        elif globalvars.tgt_version == "2" :
                            subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
                            log.debug(clientid + "TGT Version: 2") #v3 Steam
                        else :
                            subheader_encrypted = b"\x00\x02" + outerIV + subhead_decr_len + subhead_encr_len + subheader_encrypted
                            log.debug(clientid + "TGT Version: 2") #Assume v3 Steam
                        #unknown_part = b"\x01\x68" + (b"\xff" * 0x168) #THE ACTUAL TICKET!!!
                        #0 = eVersionNum
                        #1=eUniqueAccountName
                        #2=eAccountUserName
                        #3=eSteamInstanceID
                        #4=eSteamLocalUserID
                        #5=eClientExternalIPAddr
                        #6=eClientLocalIPAddr
                        #7=eUserIDTicketValidationServerIPAddr1
                        #8=eUserIDTicketValidationServerport1
                        #9=eUserIDTicketValidationServerIPAddr2
                        #10=eUserIDTicketValidationServerport2
                        #11=eClientToServerAESSessionKey
                        #12=eTicketCreationTime
                        #13=TicketValidUntilTime
                        #14=ServerReadablePart
                        clientIP = socket.inet_aton(self.address[0])
                        publicIP = clientIP[::-1]
                        #subcommand3 = b"\x00\x00\x00\x00"
                        data1_len_str = b"\x00\x80"
                        #empty1 = (b"\x00" * 0x80) #TTicketHeader unknown encrypted
                        data1 = username + username + b"\x00\x01" + publicIP + clientIP + servers + key + times
                        data1_len_empty = int(0x80 * 2) - len(binascii.b2a_hex(data1))
                        data1_full = data1 + (b"\x00" * (data1_len_empty / 2))
                        empty3 = (b"\x00" * 0x80) #unknown encrypted - RSA sig?
                        username_len = len(username)
                        #username_len_packed = struct.pack(">H", 50 + username_len)
                        accountId = userblob[b'\x06\x00\x00\x00'][username][b'\x01\x00\x00\x00'][0:16] #SteamID
                        data2 = struct.pack(">L", len(username))
                        if globalvars.tgt_version == "1" :
                            subcommand1 = b"\x00\x01" #for TGT v1
                            subcommand2 = "" #missing for TGT v1
                            empty2_dec_len = b"\x00\x42"
                            empty2_enc_len = b"\x00\x50"
                            #empty2 = (b"\x00" * 0x50) #160 chars long (80 int bytes) unknown encrypted
                            data2_len_empty = int(0x50 * 2) - len(binascii.b2a_hex(data2))
                            data2_full = data2 + (b"\x00" * (data2_len_empty / 2))
                        elif globalvars.tgt_version == "2" :
                            subcommand1 = b"\x00\x02" #for TGT v2
                            subcommand2 = b"\x00\x10" #steamID+clientIPaddress TGT v2 only
                            subcommand2 = subcommand2 + accountId + clientIP
                            empty2_dec_len = b"\x00\x52"
                            empty2_enc_len = b"\x00\x60"
                            #empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
                            data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
                            data2_full = data2 + (b"\x00" * (data2_len_empty / 2))
                        else :
                            subcommand1 = b"\x00\x02" #assume TGT v2
                            subcommand2 = b"\x00\x10" #steamID+clientIPaddress TGT v2 only
                            subcommand2 = subcommand2 + accountId + clientIP
                            empty2_dec_len = b"\x00\x52"
                            empty2_enc_len = b"\x00\x60"
                            #empty2 = (b"\x00" * 0x60) #192 chars long (96 int bytes) unknown encrypted
                            data2_len_empty = int(0x60 * 2) - len(binascii.b2a_hex(data2))
                            data2_full = data2 + (b"\x00" * (data2_len_empty / 2))
                        
                        #empty2 = username + empty2_empty[(len(username)):]
                        real_ticket = subcommand1 + data1_len_str + data1_full + IV + empty2_dec_len + empty2_enc_len + data2_full + subcommand2 + empty3
                        real_ticket_len = struct.pack(">H", len(real_ticket)) #TicketLen
                        #ticket = subheader_encrypted + unknown_part + blob_encrypted
                        ticket = subheader_encrypted + real_ticket_len + real_ticket + blob_encrypted
                        
                        ticket_signed = ticket + steam.sign_message(innerkey, ticket)
                        
                        #tgt_command = b"\x03" #Clock-skew too far out
                        if wrongpass == "1" :
                            tgt_command = b"\x02" #Incorrect password
                        else :
                            tgt_command = b"\x00" #Authenticated # AuthenticateAndRequestTGT command
                        steamtime = steam.unixtime_to_steamtime(time.time())
                        clock_skew_tolerance = b"\x00\xd2\x49\x6b\x00\x00\x00\x00"
                        authenticate = tgt_command + steamtime + clock_skew_tolerance
                        writeAccountInformation = struct.pack(">L", len(ticket_signed)) + ticket_signed #FULL TICKET (steamticket.bin)
                        self.socket.send(authenticate + writeAccountInformation)
                                     
                else :
                    log.info(clientid + "Unknown user: " + username)
                    self.socket.send(b"\x00\x00\x00\x00\x00\x00\x00\x00")
                    steamtime = steam.unixtime_to_steamtime(time.time())
                    tgt_command = b"\x01" #UNKNOWN USER
                    padding = b"\x00" * 1222
                    ticket_full = tgt_command + steamtime + padding
                    self.socket.send(ticket_full)

            elif len(command) >= 256 :
                #print(binascii.b2a_hex(command[0:3]))
                if binascii.b2a_hex(command[0:1]) == "10" : #Change password
                    #log.info(clientid + "Change password")
                    
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    
                    log.info(clientid + "Password change requested for: " + username)
                    
                    userblob = {}
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
                    #print(personalsalt)
                    self.socket.send(personalsalt) #NEW SALT PER USER
                    blobtext = self.socket.recv_withlen()
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    IV = binascii.a2b_hex("12899c8312213a123321321321543344")
                    crypted_blob = blobtext[10:]
                    if repr(steam.verify_message(key, crypted_blob)) :
                        plaintext = steam.aes_decrypt(key, IV, crypted_blob[4:-4])
                        blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
                        blob_len = len(plaintext) - 16 - blob_len
                        blob = steam.blob_unserialize(plaintext[16:-blob_len])
                        #print(blob)
                        #print(binascii.b2a_hex(blob[b"\x01\x00\x00\x00"]))
                        #print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
                        if blob[b"\x01\x00\x00\x00"] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] :
                            userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] = blob[b"\x03\x00\x00\x00"]
                            userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00'] = blob[b"\x02\x00\x00\x00"]
                            if (os.path.isfile("files/users/" + username + ".py")) :
                                with open("files/users/" + username + ".py", 'w') as userblobfile :
                                    userblobfile.write("user_registry = ")
                                    userblobfile.write(str(userblob))                              
                                log.info(clientid + "Password changed for: " + username)
                                self.socket.send(b"\x00")
                            else :
                                log.warn(clientid + "SADB file error for: " + username)
                                self.socket.send(b"\x01")
                        else :
                            log.warn(clientid + "Password change failed for: " + username)
                            self.socket.send(b"\x01")
                    else :
                        log.warn(clientid + "Password change failed for: " + username)
                        self.socket.send(b"\x01")
                elif binascii.b2a_hex(command[0:1]) == "11" : #Change question
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    
                    log.info(clientid + "Secret question change requested for: " + username)
                    
                    userblob = {}
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
                    #print(personalsalt)
                    self.socket.send(personalsalt) #NEW SALT PER USER
                    blobtext = self.socket.recv_withlen()
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    IV = binascii.a2b_hex("12899c8312213a123321321321543344")
                    crypted_blob = blobtext[10:]
                    if repr(steam.verify_message(key, crypted_blob)) :
                        plaintext = steam.aes_decrypt(key, IV, crypted_blob[4:-4])
                        blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
                        blob_len = len(plaintext) - 16 - blob_len
                        blob = steam.blob_unserialize(plaintext[16:-blob_len])
                        #print(blob)
                        #print(binascii.b2a_hex(blob[b"\x01\x00\x00\x00"]))
                        #print(binascii.b2a_hex(userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00']))
                        if blob[b"\x01\x00\x00\x00"] == userblob[b'\x05\x00\x00\x00'][username][b'\x01\x00\x00\x00'] :
                            userblob[b'\x05\x00\x00\x00'][username][b'\x03\x00\x00\x00'] = blob[b"\x02\x00\x00\x00"]
                            userblob[b'\x05\x00\x00\x00'][username][b'\x04\x00\x00\x00'] = blob[b"\x04\x00\x00\x00"]
                            userblob[b'\x05\x00\x00\x00'][username][b'\x05\x00\x00\x00'] = blob[b"\x03\x00\x00\x00"]
                            if (os.path.isfile("files/users/" + username + ".py")) :
                                with open("files/users/" + username + ".py", 'w') as userblobfile :
                                    userblobfile.write("user_registry = ")
                                    userblobfile.write(str(userblob))                              
                                log.info(clientid + "Secret question changed for: " + username)
                                self.socket.send(b"\x00")
                            else :
                                log.warn(clientid + "SADB file error for: " + username)
                                self.socket.send(b"\x01")
                        else :
                            log.warn(clientid + "Secret question change failed for: " + username)
                            self.socket.send(b"\x01")
                    else :
                        log.warn(clientid + "Secret question change failed for: " + username)
                        self.socket.send(b"\x01")
                elif binascii.b2a_hex(command[0:1]) == "12" : #Change email
                    log.info(clientid + "Change email")
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    data1_len = int(data1_len, 16) * 2
                    userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    ticket_len = int(ticket_len, 16) * 2
                    ticket = ticket_full[2:ticket_len + 2]
                    postticketdata = ticket_full[2 + ticket_len + 4:]
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    iv = binascii.a2b_hex(postticketdata[0:32])
                    encdata_len = int(postticketdata[36:40], 16) * 2
                    encdata = postticketdata[40:40 + encdata_len]
                    decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
                    decodedmessage = binascii.a2b_hex(decodedmessage)
                    username_len_new = struct.unpack("<H", decodedmessage[0:2])
                    username_len_new = (2 + username_len_new[0]) * 2
                    header = username_len_new + 8
                    blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
                    blob_len = (blob_len[0])
                    blob = (decodedmessage[header:header + blob_len])
                    padding_byte = blob[-1:]
                    padding_int = struct.unpack(">B", padding_byte)
                    new_email_addr = blob[:-padding_int[0]]
                    new_email_addr = new_email_addr + b"\x00"
                    
                    userblob = {}
                    execdict_new = {}
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    personalsalt = userblob[b'\x05\x00\x00\x00'][username][b'\x02\x00\x00\x00']
                    new_email = {}
                    new_email = {b"\x0b\x00\x00\x00": new_email_addr}
                    userblob.update(new_email)
                    with open("files/users/" + username + ".py", 'w') as g:
                        g.write("user_registry = " + str(userblob))
                    secretkey = {b'\x05\x00\x00\x00'}
                    def without_keys(d, keys) :
                        return {x: d[x] for x in d if x not in keys}
                    execdict_new = without_keys(userblob, secretkey)
                    #print(userblob)
                    #print(execdict_new)
                    blob = steam.blob_serialize(execdict_new)
                    #print(blob)
                    bloblen = len(blob)
                    log.debug("Blob length: " + str(bloblen))
                    innerkey = binascii.a2b_hex("10231230211281239191238542314233") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                    #innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                    innerIV = userIV
                    blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                    blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                    blob_signature = steam.sign_message(innerkey, blob_encrypted)
                    blob_encrypted_len = 10 + len(blob_encrypted) + 20
                    blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted
                    ticket = ticket + blob_encrypted
                    ticket_signed = ticket + steam.sign_message(innerkey, ticket)
                    self.socket.send(b"\x00" + blob_encrypted + blob_signature)
                elif binascii.b2a_hex(command[0:1]) == "05" : #Subscribe
                    log.info(clientid + "Subscribe to package")
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    data1_len = int(data1_len, 16) * 2
                    userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    ticket_len = int(ticket_len, 16) * 2
                    ticket = ticket_full[2:ticket_len + 2]
                    postticketdata = ticket_full[2 + ticket_len + 4:]
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    iv = binascii.a2b_hex(postticketdata[0:32])
                    encdata_len = int(postticketdata[36:40], 16) * 2
                    encdata = postticketdata[40:40 + encdata_len]
                    decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
                    decodedmessage = binascii.a2b_hex(decodedmessage)
                    username_len_new = struct.unpack("<H", decodedmessage[0:2])
                    username_len_new = (2 + username_len_new[0]) * 2
                    header = username_len_new + 8
                    blob_len = struct.unpack("<H", decodedmessage[header + 2:header + 4])
                    blob_len = (blob_len[0])
                    blob = (decodedmessage[header:header + blob_len])
                    padding_byte = blob[-1:]
                    padding_int = struct.unpack(">B", padding_byte)
                    blobnew = steam.blob_unserialize(decodedmessage[header:header + blob_len])
                    #------------------------------------------------------------------
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        execdict = {}
                        execdict_new = {}
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                        steamtime = steam.unixtime_to_steamtime(time.time())
                        new_sub = {blobnew[b"\x01\x00\x00\x00"]: {b'\x01\x00\x00\x00': steamtime, b'\x02\x00\x00\x00': b'\x00\x00\x00\x00\x00\x00\x00\x00', b'\x03\x00\x00\x00': b'\x00\x00', b'\x05\x00\x00\x00': b'\x00', b'\x06\x00\x00\x00': b'\x1f\x00'}}
                        new_buy = {blobnew[b"\x01\x00\x00\x00"]: blobnew[b"\x02\x00\x00\x00"]}
                        receipt_dict = {}
                        receipt_dict_01 = {}
                        receipt_sub_dict = {}
                        subid = list(new_buy.keys())[0]
                        execdict[b"\x07\x00\x00\x00"].update(new_sub)
                        #pprint.pprint(new_sub)
                        #pprint.pprint(new_buy)
                        #pprint.pprint(subid)
                        if new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "WONCDKey\x00" or new_buy[subid][b'\x02\x00\x00\x00'][b'\x01\x00\x00\x00'] == "ValveCDKey\x00" :
                            receipt_sub_dict[b"\x01\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x01\x00\x00\x00"]
                            receipt_sub_dict[b"\x02\x00\x00\x00"] = str(random.randint(11111111, 99999999)) + b"\x00"
                            receipt_dict_01[b"\x01\x00\x00\x00"] = b"\x06"
                            receipt_dict_01[b"\x02\x00\x00\x00"] = receipt_sub_dict
                            receipt_dict[subid] = receipt_dict_01
                        else :
                            receipt_sub_dict[b"\x01\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x01\x00\x00\x00"]
                            receipt_sub_dict[b"\x02\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x02\x00\x00\x00"][12:]
                            receipt_sub_dict[b"\x03\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x03\x00\x00\x00"]
                            receipt_sub_dict[b"\x07\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x07\x00\x00\x00"]
                            receipt_sub_dict[b"\x08\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x08\x00\x00\x00"]
                            receipt_sub_dict[b"\x09\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x09\x00\x00\x00"]
                            receipt_sub_dict[b"\x0a\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x0a\x00\x00\x00"]
                            receipt_sub_dict[b"\x0b\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x0b\x00\x00\x00"]
                            receipt_sub_dict[b"\x0c\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x0c\x00\x00\x00"]
                            receipt_sub_dict[b"\x0d\x00\x00\x00"] = str(random.randint(111111, 999999)) + b"\x00"
                            receipt_sub_dict[b"\x0e\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x14\x00\x00\x00"]
                            receipt_sub_dict[b"\x0f\x00\x00\x00"] = new_buy[subid][b"\x02\x00\x00\x00"][b"\x15\x00\x00\x00"]
                            receipt_sub_dict[b"\x10\x00\x00\x00"] = datetime.datetime.now().strftime("%d/%m/%Y") + b"\x00"
                            receipt_sub_dict[b"\x11\x00\x00\x00"] = datetime.datetime.now().strftime("%H:%M:%S") + b"\x00"
                            receipt_sub_dict[b"\x12\x00\x00\x00"] = str(random.randint(11111111, 99999999)) + b"\x00"
                            receipt_sub_dict[b"\x13\x00\x00\x00"] = b"\x00\x00\x00\x00"
                            receipt_dict_01[b"\x01\x00\x00\x00"] = b"\x05"
                            receipt_dict_01[b"\x02\x00\x00\x00"] = receipt_sub_dict
                            receipt_dict[subid] = receipt_dict_01
                        new_buy.clear()
                        execdict[b"\x0f\x00\x00\x00"].update(receipt_dict)
                        with open("files/users/" + username + ".py", 'w') as g:
                            g.write("user_registry = " + str(execdict))
                        secretkey = {b'\x05\x00\x00\x00'}
                        def without_keys(d, keys) :
                            return {x: d[x] for x in d if x not in keys}
                        execdict_new = without_keys(execdict, secretkey)
                        #print(execdict)
                        #print(execdict_new)
                        blob = steam.blob_serialize(execdict_new)
                        #print(blob)
                        bloblen = len(blob)
                        log.debug("Blob length: " + str(bloblen))
                        innerkey = binascii.a2b_hex("10231230211281239191238542314233") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                        blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                        blob_signature = steam.sign_message(innerkey, blob_encrypted)
                        blob_encrypted_len = 10 + len(blob_encrypted) + 20
                        blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
                        self.socket.send(b"\x00" + blob_encrypted)
                elif binascii.b2a_hex(command[0:1]) == "09" : #Ticket Login
                    ticket_full = binascii.b2a_hex(command)
                    command = ticket_full[0:2]
                    ticket_len = ticket_full[2:6]
                    tgt_ver = ticket_full[6:10]
                    data1_len = ticket_full[10:14]
                    data1_len = int(data1_len, 16) * 2
                    userIV = binascii.a2b_hex(ticket_full[14 + data1_len:14 + data1_len + 32])
                    username_len = ticket_full[314:318]
                    username = binascii.a2b_hex(ticket_full[14:14 + (int(username_len, 16) * 2)])
                    log.info(clientid + "Ticket login for: " + username)
                    ticket_len = int(ticket_len, 16) * 2
                    postticketdata = ticket_full[2 + ticket_len + 4:]
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    iv = binascii.a2b_hex(postticketdata[0:32])
                    encdata_len = int(postticketdata[36:40], 16) * 2
                    encdata = postticketdata[40:40 + encdata_len]
                    decodedmessage = binascii.b2a_hex(steam.aes_decrypt(key, iv, binascii.a2b_hex(encdata)))
                    #------------------------------------------------------------------
                    if (os.path.isfile("files/users/" + username + ".py")) :
                        #self.socket.send(b"\x00")
                        # create login ticket
                        execdict = {}
                        execdict_new = {}
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                        for sub_dict in execdict:
                            if sub_dict == b"\x07\x00\x00\x00":
                                for sub_sub_dict in execdict[sub_dict]:
                                    if execdict[sub_dict][sub_sub_dict][b"\x03\x00\x00\x00"] == b"\x00\x00":
                                        execdict[sub_dict][sub_sub_dict][b"\x03\x00\x00\x00"] = b"\x01\x00"
                                        execdict[sub_dict][sub_sub_dict][b"\x05\x00\x00\x00"] = b"\x01"
                                        execdict[sub_dict][sub_sub_dict][b"\x06\x00\x00\x00"] = b"\x00\x00"
                        with open("files/users/" + username + ".py", 'w') as g:
                            g.write("user_registry = " + str(execdict))
                        secretkey = {b'\x05\x00\x00\x00'}
                        def without_keys(d, keys) :
                            return {x: d[x] for x in d if x not in keys}
                        execdict_new = without_keys(execdict, secretkey)
                        #print(execdict)
                        #print(execdict_new)
                        blob = steam.blob_serialize(execdict_new)
                        #print(blob)
                        bloblen = len(blob)
                        log.debug("Blob length: " + str(bloblen))
                        innerkey = binascii.a2b_hex("10231230211281239191238542314233") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        innerIV  = binascii.a2b_hex("12899c8312213a123321321321543344") #ONLY FOR BLOB ENCRYPTION USING AES-CBC
                        blob_encrypted = steam.aes_encrypt(innerkey, innerIV, blob)
                        blob_encrypted = struct.pack("<L", bloblen) + innerIV + blob_encrypted
                        blob_signature = steam.sign_message(innerkey, blob_encrypted)
                        blob_encrypted_len = 10 + len(blob_encrypted) + 20
                        blob_encrypted = struct.pack(">L", blob_encrypted_len) + b"\x01\x45" + struct.pack("<LL", blob_encrypted_len, 0) + blob_encrypted + blob_signature
                        self.socket.send(b"\x00" + blob_encrypted)
                        
                        execdict = {}
                        with open("files/users/" + username + ".py", 'r') as f:
                            userblobstr = f.read()
                            execdict = ast.literal_eval(userblobstr[16:len(userblobstr)])
                        for sub_dict in execdict:
                            if sub_dict == b"\x07\x00\x00\x00":
                                for sub_sub_dict in execdict[sub_dict]:
                                    if execdict[sub_dict][sub_sub_dict][b"\x03\x00\x00\x00"] == b"\x01\x00":
                                        #execdict[sub_dict][sub_sub_dict][b"\x03\x00\x00\x00"] = b"\x01\x00"
                                        execdict[sub_dict][sub_sub_dict][b"\x05\x00\x00\x00"] = b"\x00"
                                        #execdict[sub_dict][sub_sub_dict][b"\x06\x00\x00\x00"] = b"\x00\x00"
                        with open("files/users/" + username + ".py", 'w') as g:
                            g.write("user_registry = " + str(execdict))
                else :
                    log.debug(clientid + "Unknown command: " + binascii.b2a_hex(command[0:1])) #04 logoff
                    self.socket.send(b"\x01")
            elif len(command) == 1 :
                if command == 0x1d or command == 0x1e : #Check username - new user
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + b"\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)

                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print(plaintext)
                    plainblob = steam.blob_unserialize(plaintext)
                    #print(plainblob)
                    username = plainblob[b'\x01\x00\x00\x00']
                    username_str = username.rstrip(b'\x00')
                    #print(len(username_str))
                    log.info(clientid + "New user: check username exists: " + username_str)
                    if (os.path.isfile("files/users/" + username_str + ".py")) :
                        log.warn(clientid + "New user: username already exists")
                        self.socket.send(b"\xff")#not working
                    else :
                        log.info(clientid + "New user: username not found")
                        self.socket.send(b"\x00")
                elif command == 0x22 : #Check email - new user
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + b"\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)

                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print(plaintext)
                    plainblob = steam.blob_unserialize(plaintext)
                    #print(plainblob)
                    email = plainblob[b'\x01\x00\x00\x00']
                    email_str = email.rstrip(b'\x00')
                    #print(len(username_str))
                    log.info(clientid + "New user: check email exists: " + email_str)
                    email_exists = False
                    for file in os.listdir("files/users/"):
                        if file.endswith("py"):
                            with open("files/users/" + file, 'r') as f:
                                userblobstr = f.read()
                                userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                            email_addr = userblob[b'\x0b\x00\x00\x00']
                            if email_addr.rstrip(b'\x00') == email_str :
                                email_exists = True
                                break
                    if email_exists == True  :
                        log.warn(clientid + "New user: email already in use")
                        self.socket.send(b"\xff")#not working
                    else :
                        log.info(clientid + "New user: email ok to use")
                        self.socket.send(b"\x00")
                elif command == 0x01 : #New user
                    log.info(clientid + "New user: Create user")
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("9525173d72e87cbbcbdc86146587aebaa883ad448a6f814dd259bff97507c5e000cdc41eed27d81f476d56bd6b83a4dc186fa18002ab29717aba2441ef483af3970345618d4060392f63ae15d6838b2931c7951fc7e1a48d261301a88b0260336b8b54ab28554fb91b699cc1299ffe414bc9c1e86240aa9e16cae18b950f900f") + b"\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)

                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print(plaintext)
                    plainblob = steam.blob_unserialize(plaintext)
                    #print(plainblob)
                    
                    username = plainblob[b'\x01\x00\x00\x00']
                    username_str = username.rstrip(b'\x00')
                    
                    #invalid6 = {b'\x06\x00\x00\x00'}
                    #def without_keys(d, keys) :
                    #    return {x: d[x] for x in d if x not in keys}
                    
                    #plainblob_fixed = without_keys(plainblob, invalid6)
                    
                    #dict6 = {}
                    #dict6 = {b'\x06\x00\x00\x00': {username_str: {b'\x01\x00\x00\x00': b'\x10\x20\x30\x40\x00\x00\x00\x00', b'\x02\x00\x00\x00': b'\x00\x01', b'\x03\x00\x00\x00': {}}}}
                    
                    #plainblob_fixed.update(dict6)
                    
                    newsteamid = os.urandom(4) + b"\x00\x00\x00\x00" #generate random steamId
                    plainblob[b'\x06\x00\x00\x00'][username_str][b'\x01\x00\x00\x00'] = newsteamid
                    
                    invalid7 = {b'\x07\x00\x00\x00'}
                    def without_keys(d, keys) :
                        return {x: d[x] for x in d if x not in keys}
                    
                    plainblob_fixed = without_keys(plainblob, invalid7)
                    
                    dict7 = {}
                    dict7 = {b'\x07\x00\x00\x00': {b'\x00\x00\x00\x00': {b'\x01\x00\x00\x00': b'\xe0\xe0\xe0\xe0\xe0\xe0\xe0\x00', b'\x02\x00\x00\x00': b'\x00\x00\x00\x00\x00\x00\x00\x00', b'\x03\x00\x00\x00': b'\x01\x00', b'\x05\x00\x00\x00': b'\x00', b'\x06\x00\x00\x00': b'\x1f\x00'}}}
                    
                    plainblob_fixed.update(dict7)
                    
                    dictf = {}
                    dictf = {b'\x0f\x00\x00\x00': {b'\x00\x00\x00\x00': {b'\x01\x00\x00\x00': b'\x07', b'\x02\x00\x00\x00': {}}}}
                    
                    plainblob_fixed.update(dictf)
                        
                    with open("files/users/" + username_str + ".py", 'w') as userblobfile :
                        userblobfile.write("user_registry = ")
                        userblobfile.write(str(plainblob_fixed))
                    
                    self.socket.send(b"\x00")
                elif command == 0x0e :
                    log.info(clientid + "command: Lost password - username check")
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)
                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    print(plaintext)
                    blobdict = steam.blob_unserialize(plaintext)
                    print(blobdict)
                    usernamechk = blobdict[b'\x01\x00\x00\x00']
                    username_str = usernamechk.rstrip(b'\x00')
                    if os.path.isfile("files/users/" + username_str + ".py") :
                        self.socket.send(b"\x00")
                    else :
                        self.socket.send(b"\x01")
                elif command == 0x0f :
                    log.info(clientid + "command: Lost password - reset")
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)
                    reply = self.socket.recv_withlen()

                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    print(plaintext)
                    blobdict = steam.blob_unserialize(plaintext)
                    print(blobdict)
                   
                    usernamechk = blobdict[b'\x01\x00\x00\x00']
                    username_str = usernamechk.rstrip(b'\x00')
                    with open("files/users/" + username_str + ".py", 'r') as userblobfile:
                        userblobstr = userblobfile.read()
                        userblob = ast.literal_eval(userblobstr[16:len(userblobstr)])
                    #print(userblob)
                    personalsalt = userblob[b'\x05\x00\x00\x00'][username_str][b'\x02\x00\x00\x00']
                    #print(personalsalt)
                    self.socket.send(personalsalt) #NEW SALT PER USER
                    blobtext = self.socket.recv_withlen()
                    blobtext = self.socket.recv_withlen()
                    key = binascii.a2b_hex("10231230211281239191238542314233")
                    IV = binascii.a2b_hex("12899c8312213a123321321321543344")
                    crypted_blob = blobtext[10:]
                    if repr(steam.verify_message(key, crypted_blob)):
                        plaintext = steam.aes_decrypt(
                            key, IV, crypted_blob[4:-4])
                        blob_len = int(binascii.b2a_hex(plaintext[18:19]), 16)
                        blob_len = len(plaintext) - 16 - blob_len
                        blob = steam.blob_unserialize(plaintext[16:-blob_len])
                        print(blob)
                    
                elif command == 0x20 :
                    log.info(clientid + "command: Lost password - email check")
                elif command == 0x21 :
                    log.info(clientid + "command: Lost password - product check")
                else :
                    # This is cheating. I've just cut'n'pasted the hex from the network_key. FIXME
                    #BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex("bf973e24beb372c12bea4494450afaee290987fedae8580057e4f15b93b46185b8daf2d952e24d6f9a23805819578693a846e0b8fcc43c23e1f2bf49e843aff4b8e9af6c5e2e7b9df44e29e3c1c93f166e25e42b8f9109be8ad03438845a3c1925504ecc090aabd49a0fc6783746ff4e9e090aa96f1c8009baf9162b66716059") + b"\x02\x01\x11"
                    BERstring = binascii.a2b_hex("30819d300d06092a864886f70d010101050003818b0030818702818100") + binascii.a2b_hex(self.config["net_key_n"][2:]) + b"\x02\x01\x11"
                    signature = steam.rsa_sign_message_1024(steam.main_key_sign, BERstring)
                    reply = struct.pack(">H", len(BERstring)) + BERstring + struct.pack(">H", len(signature)) + signature
                    self.socket.send(reply)

                    reply = self.socket.recv_withlen()
                
                    RSAdata = reply[2:130]
                    datalength = struct.unpack(">L", reply[130:134])[0]
                    cryptedblob_signature = reply[134:136]
                    cryptedblob_length = reply[136:140]
                    cryptedblob_slack = reply[140:144]
                    cryptedblob = reply[144:]
                
                    key = steam.get_aes_key(RSAdata, steam.network_key)
                    log.debug("Message verification:" + repr(steam.verify_message(key, cryptedblob)))
                    plaintext_length = struct.unpack("<L", cryptedblob[0:4])[0]
                    IV = cryptedblob[4:20]
                    ciphertext = cryptedblob[20:-20]
                    plaintext = steam.aes_decrypt(key, IV, ciphertext)
                    plaintext = plaintext[0:plaintext_length]
                    #print steam.blob_unserialize(plaintext)
                
                    self.socket.send(b"\x00")
            else :
                log.warning(clientid + "Invalid command length: " + str(len(command)))

        else :
            data = self.socket.recv(65535)
            log.warning(clientid + "Invalid command: " + binascii.b2a_hex(command[1:5]))
            log.warning(clientid + "Extra data:", binascii.b2a_hex(data))

        self.socket.close()
        log.info(clientid + "Disconnected from Auth Server")
